Index: lua/wire/client/TextEditor.lua
===================================================================
--- lua/wire/client/TextEditor.lua	(revision 2200)
+++ lua/wire/client/TextEditor.lua	(working copy)
@@ -399,6 +399,9 @@
 	
 	self.Scroll[1] = math.floor(self.ScrollBar:GetScroll() + 1)
 	
+	self.blockcomment = nil
+	self.multilinestring = nil
+	
 	for i=self.Scroll[1],self.Scroll[1]+self.Size[1]+1 do
 		self:PaintLine(i)
 	end
@@ -1604,70 +1607,151 @@
 			self.NextPattern(" *")
 			if !self.character then break end
 			
-			-- eat next token
-			if self:NextPattern("^[0-9][0-9.e]*") then
-				tokenname = "number"
+			if (self.blockcomment) then
+				while self.character do -- Find the ending ]
+					if (self.character == "]") then
+						self:NextCharacter()
+						if (self.character == "#") then -- Check if there is a # directly after the ending ]
+							tokenname = "comment"
+							self.blockcomment = nil
+							break
+						end
+					end
+					if self.character == "\\" then self:NextCharacter() end
+					self:NextCharacter()
+				end
+				if (tokenname == "") then -- If no ending ]# was found...
+					tokenname = "comment"
+				else						
+					self:NextCharacter()
+				end
+			elseif (self.multilinestring) then
+				while self.character do -- Find the ending "
+					if (self.character == '"') then
+						self.multilinestring = nil
+						tokenname = "string"
+						break
+					end
+					if (self.character == "\\") then self:NextCharacter() end
+					self:NextCharacter()
+				end
 				
-			elseif self:NextPattern("^[a-z][a-zA-Z0-9_]*") then
-				local sstr = string.Trim(self.tokendata)
-				if highlightmode then
-					if highlightmode == 1 and istype(sstr) then
-						tokenname = "typename"
-					elseif highlightmode == 2 and (sstr == "all" or sstr == "none") then
-						tokenname = "directive"
-					elseif highlightmode == 3 and istype(sstr) then
-						tokenname = "typename"
-						highlightmode = nil
+				if (tokenname == "") then -- if no ending " was found...
+					tokenname = "string"
+				else
+					self:NextCharacter()
+				end
+			else
+				-- eat next token
+				if self:NextPattern("^[0-9][0-9.e]*") then
+					tokenname = "number"
+					
+				elseif self:NextPattern("^[a-z][a-zA-Z0-9_]*") then
+					local sstr = string.Trim(self.tokendata)
+					if highlightmode then
+						if highlightmode == 1 and istype(sstr) then
+							tokenname = "typename"
+						elseif highlightmode == 2 and (sstr == "all" or sstr == "none") then
+							tokenname = "directive"
+						elseif highlightmode == 3 and istype(sstr) then
+							tokenname = "typename"
+							highlightmode = nil
+						else
+							tokenname = "notfound"
+						end
 					else
-						tokenname = "notfound"
+						-- is this a keyword or a function?
+						local char = self.character or ""
+						local keyword = char != "("
+						
+						self:NextPattern(" *")
+						
+						if self.character == "]" then
+							-- X[Y,typename]
+							tokenname = istype(sstr) and "typename" or "notfound"
+						elseif keywords[sstr][keyword] then
+							tokenname = "keyword"
+							if sstr == "foreach" then highlightmode = 3 end
+						elseif wire_expression2_funclist[sstr] then
+							tokenname = "function"
+						else
+							tokenname = "notfound"
+						end
 					end
-				else
-					-- is this a keyword or a function?
-					local char = self.character or ""
-					local keyword = char != "("
 					
-					self:NextPattern(" *")
+				elseif self:NextPattern("^[A-Z][a-zA-Z0-9_]*") then
+					tokenname = "variable"
 					
-					if self.character == "]" then
-						-- X[Y,typename]
-						tokenname = istype(sstr) and "typename" or "notfound"
-					elseif keywords[sstr][keyword] then
-						tokenname = "keyword"
-						if sstr == "foreach" then highlightmode = 3 end
-					elseif wire_expression2_funclist[sstr] then
-						tokenname = "function"
+				elseif self.character == '"' then
+					self:NextCharacter()
+					while self.character do -- Find the ending "
+						if (self.character == '"') then
+							tokenname = "string"
+							break
+						end
+						if (self.character == "\\") then self:NextCharacter() end
+						self:NextCharacter()
+					end
+					
+					if (tokenname == "") then -- If no ending " was found...
+						self.multilinestring = true
+						tokenname = "string"
 					else
-						tokenname = "notfound"
+						self:NextCharacter()
 					end
-				end
-				
-			elseif self:NextPattern("^[A-Z][a-zA-Z0-9_]*") then
-				tokenname = "variable"
-				
-			elseif self.character == '"' then
-				self:NextCharacter()
-				while self.character and self.character != '"' do
-					if self.character == "\\" then self:NextCharacter() end
+					
+					--[[ This is the old code. Does not support multiline strings
+						local foundending = false
+						while self.character and self.character != '"' do
+							if self.character == "\\" then self:NextCharacter() end
+							self:NextCharacter()
+						end
+						self:NextCharacter()
+						
+						tokenname = "string"
+					]]
+					
+				elseif self:NextPattern("#[^ ]*") then
+					if (self.tokendata:sub(2,2) == "[") then -- Check if there is a [ directly after the #
+						self:NextCharacter()
+						while self.character do -- Find the ending ]
+							if (self.character == "]") then
+								self:NextCharacter()
+								if (self.character == "#") then -- Check if there is a # directly after the ending ]
+									tokenname = "comment"
+									break
+								end
+							end
+							if self.character == "\\" then self:NextCharacter() end
+							self:NextCharacter()
+						end
+						if (tokenname == "") then -- If no ending ]# was found...
+							self.blockcomment = true
+							tokenname = "comment"
+						else						
+							self:NextCharacter()
+						end
+					end
+					
+					if (tokenname == "") then
+					
+						if PreProcessor["PP_"..self.tokendata:sub(2)] then
+							-- there is a preprocessor command by that name => mark as such
+							tokenname = "ppcommand"
+						else
+							-- eat the rest and mark as a comment
+							self:NextPattern(".*")
+							tokenname = "comment"
+						end
+						
+					end
+				else
 					self:NextCharacter()
+					
+					tokenname = "operator"
 				end
-				self:NextCharacter()
 				
-				tokenname = "string"
-				
-			elseif self:NextPattern("#[^ ]*") then
-				if PreProcessor["PP_"..self.tokendata:sub(2)] then
-					-- there is a preprocessor command by that name => mark as such
-					tokenname = "ppcommand"
-				else
-					-- eat the rest and mark as a comment
-					self:NextPattern(".*")
-					tokenname = "comment"
-				end
-			else
-				self:NextCharacter()
-				
-				tokenname = "operator"
-			end
+			end -- blockcomment check
 			
 			color = colors[tokenname]
 			if #cols > 1 and color == cols[#cols][2] then
